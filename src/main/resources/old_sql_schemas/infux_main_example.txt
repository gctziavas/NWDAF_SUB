package io.nwdaf.eventsubscription;

import java.time.Instant;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.TimeZone;
import java.util.UUID;
import java.util.concurrent.TimeUnit;

import org.json.JSONObject;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.CommandLineRunner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.domain.EntityScan;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.boot.web.client.RestTemplateBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.core.env.Environment;
import org.springframework.scheduling.annotation.EnableAsync;
import org.springframework.web.client.RestTemplate;

import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import com.influxdb.annotations.Column;
import com.influxdb.annotations.Measurement;
import com.influxdb.client.InfluxDBClient;
import com.influxdb.client.InfluxDBClientFactory;
import com.influxdb.client.QueryApi;
import com.influxdb.client.WriteApiBlocking;
import com.influxdb.client.domain.Authorization;
import com.influxdb.client.domain.Bucket;
import com.influxdb.client.domain.BucketRetentionRules;
import com.influxdb.client.domain.Permission;
import com.influxdb.client.domain.PermissionResource;
import com.influxdb.client.domain.WritePrecision;
import com.influxdb.client.write.Point;
import com.influxdb.client.write.WriteParameters;
import com.influxdb.query.FluxRecord;
import com.influxdb.query.FluxTable;

import io.nwdaf.eventsubscription.api.config.NwdafSubProperties;
import io.nwdaf.eventsubscription.model.NFType;
import io.nwdaf.eventsubscription.model.NFType.NFTypeEnum;
import io.nwdaf.eventsubscription.model.NfLoadLevelInformation;
import io.nwdaf.eventsubscription.model.NfStatus;
import io.nwdaf.eventsubscription.model.NnwdafEventsSubscription;
import io.nwdaf.eventsubscription.model.Snssai;
import io.nwdaf.eventsubscription.notify.NotifyPublisher;

@EnableConfigurationProperties(NwdafSubProperties.class)
@SpringBootApplication
@EnableAsync
@EntityScan({"io.nwdaf.eventsubscription.repository"})
public class NwdafSubApplication {
	
	@Autowired
	private Environment env;
	
	private static final Logger log = LoggerFactory.getLogger(NwdafSubApplication.class);
	
	@Autowired
	private NotifyPublisher notifyPublisher;
	
	private InfluxDBClient influxDBClient;
	
	private WriteApiBlocking writeApi;
	
	private QueryApi queryApi;
	
	public static void main(String[] args) {
		SpringApplication.run(NwdafSubApplication.class, args);
		
		
	}
	
	@Bean
	public RestTemplate restTemplate(RestTemplateBuilder builder) {
		return builder.build();
	}
	
	@Bean
	public CommandLineRunner run() throws JsonProcessingException{
		
		String clientURL = env.getProperty("nnwdaf-eventsubscription.client.dev_url");
		String prometheusURL = env.getProperty("nnwdaf-eventsubscription.prometheus_url");
		String databaseURL = env.getProperty("nnwdaf-eventsubscription.influxdb.databaseURL");
		String token = env.getProperty("nnwdaf-eventsubscription.influxdb.token");
		String bucketName = env.getProperty("nnwdaf-eventsubscription.influxdb.bucket");
		String org = env.getProperty("nnwdaf-eventsubscription.influxdb.org");
		String orgId = env.getProperty("nnwdaf-eventsubscription.influxdb.orgId");
		
		return args -> {
			Long subId = 0l;
			influxDBClient = InfluxDBClientFactory.create(databaseURL, token.toCharArray());
			if (!influxDBClient.ping()) {
			    log.error("Error pinging influxdb server.");
			}
			else {
				log.info("Connected to influxDB: "+databaseURL);
				try {
					BucketRetentionRules retention = new BucketRetentionRules();
			        retention.setEverySeconds(2592000);
	
			        Bucket bucket = influxDBClient.getBucketsApi().createBucket(bucketName, retention, orgId);
	
			        //
			        // Create access token to "nwdaf_metrics"
			        //
			        PermissionResource resource = new PermissionResource();
			        resource.setId(bucket.getId());
			        resource.setOrgID(orgId);
			        resource.setType(PermissionResource.TYPE_BUCKETS);
	
			        // Read permission
			        Permission read = new Permission();
			        read.setResource(resource);
			        read.setAction(Permission.ActionEnum.READ);
	
			        // Write permission
			        Permission write = new Permission();
			        write.setResource(resource);
			        write.setAction(Permission.ActionEnum.WRITE);
			        
			        Authorization authorization = influxDBClient.getAuthorizationsApi()
			                .createAuthorization(orgId, Arrays.asList(read, write));
			        log.info(authorization.getToken());
			        influxDBClient = InfluxDBClientFactory.create(databaseURL, authorization.getToken().toCharArray());
				}catch(Exception e) {
					log.info("Bucket "+bucketName+" already created.");
				}
				
				// Close it if your application is terminating or you are not using it anymore.
				Runtime.getRuntime().addShutdownHook(new Thread(influxDBClient::close));
				
				writeApi = influxDBClient.getWriteApiBlocking();
				
				NfLoadLevelInformation nfloadlevel = new  NfLoadLevelInformation().nfCpuUsage(100)
						.nfMemoryUsage(50).nfStorageUsage(25)
						.nfInstanceId(UUID.fromString("550e8400-e29b-41d4-a716-446655440000"))
						.time(Instant.now())
//						.nfType(new NFType().nfType(NFTypeEnum.AMF));
						.nfStatus(new NfStatus().statusRegistered(1).statusUnregistered(2).statusUndiscoverable(3));
				queryApi = influxDBClient.getQueryApi();
				String measurement = "nfloadlevel";
				
				//point:
				ObjectMapper objectMapper = new ObjectMapper();
				objectMapper.registerModule(new JavaTimeModule());
				Map<String, Object> map = objectMapper.convertValue(nfloadlevel, new TypeReference<Map<String, Object>>() {});
				Point p = Point.measurement(measurement).time(nfloadlevel.getTime(),WritePrecision.NS).addFields(map);
				WriteParameters params = new WriteParameters(bucketName,org,WritePrecision.NS);
				writeApi.writePoint(p,params);
				
//				String flux = "from(bucket:\""+bucketName+"\") |> range(start: 0) |> filter(fn: (r) => r._measurement == \""+measurement+"\") |> filter(fn: (r) => r[\"_field\"] =~ /^(nfCpuUsage|nfMemoryUsage)$/)";
				String flux = "from(bucket:\""+bucketName+"\") |> range(start: 0) |> filter(fn: (r) => r._measurement == \""+measurement+"\")";
				List<FluxTable> tables = queryApi.query(flux,org);
				List<NfLoadLevelInformation> res = new ArrayList<>();
				List<Map<String,Object>> res_maps = new ArrayList<>();
				for(int i=0;i<tables.get(0).getRecords().size();i++) {
					res_maps.add(new HashMap<>());
				}
				
				for (int i =0;i<tables.size();i++) {
					List<FluxRecord> records = tables.get(i).getRecords();
						for (int j=0;j<records.size();j++) {
							 res_maps.get(j).put(records.get(j).getField(),records.get(j).getValue());
						}
				}
				for(int i=0;i<res_maps.size();i++) {
					res.add(objectMapper.readValue((new JSONObject(res_maps.get(i))).toString(),NfLoadLevelInformation.class));
				}
				log.info(res.get(3).toString());
				notifyPublisher.publishNotification(subId);
			}
			
		};
	}
	
	public static Logger getLogger() {
		return NwdafSubApplication.log;
	}
	
}
